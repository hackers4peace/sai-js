export interface RuntimeConfig {
  backendBaseUrl: string
  vapidPublicKey: string
  languages: string[]
}

// Cache the config after first load to avoid repeated fetches
// Using module-level variable ensures single source of truth
let cachedConfig: RuntimeConfig | null = null

/**
 * Loads the runtime configuration from config.json
 * This file is generated by docker-entrypoint.sh at container startup
 *
 * @returns Promise resolving to the runtime configuration
 * @throws Error if config cannot be loaded (network error, invalid JSON, etc.)
 *
 * @example
 * // Call once at app startup
 * await loadRuntimeConfig();
 *
 * // Then use getRuntimeConfig() anywhere
 * const config = getRuntimeConfig();
 */
export async function loadRuntimeConfig(): Promise<RuntimeConfig> {
  // Return cached config if already loaded
  // This makes subsequent calls instant and prevents race conditions
  if (cachedConfig) {
    return cachedConfig
  }

  try {
    // Use BASE_URL to support apps deployed at subpaths (e.g., /my-app/)
    // Vite sets this based on the `base` option in vite.config.ts
    // Falls back to "/" for root deployments
    const baseUrl = import.meta.env.BASE_URL || '/'
    const response = await fetch(`${baseUrl}config.json`)

    // Check for HTTP errors (404, 500, etc.)
    if (!response.ok) {
      throw new Error(`Failed to load config: ${response.status}`)
    }

    // Parse and cache the configuration
    // The non-null assertion (!) is safe because we just set it
    cachedConfig = await response.json()
    return cachedConfig!
  } catch (error) {
    // Log the error for debugging, then re-throw
    // This ensures the app doesn't silently fail with missing config
    console.error('Failed to load runtime config:', error)
    throw new Error('Failed to load runtime config')
  }
}

/**
 * Synchronously retrieves the cached runtime configuration
 * Must call loadRuntimeConfig() before using this function
 *
 * @returns The cached runtime configuration
 * @throws Error if config has not been loaded yet
 *
 * @example
 * // In any component or service (after loadRuntimeConfig has been called)
 * const config = getRuntimeConfig();
 * console.log(config.API_URL);
 */
export function getRuntimeConfig(): RuntimeConfig {
  // Fail fast with a clear error message if config wasn't loaded
  // This catches programming errors where getRuntimeConfig is called too early
  if (!cachedConfig) {
    throw new Error('Runtime config not loaded. Call loadRuntimeConfig() first.')
  }
  return cachedConfig
}
